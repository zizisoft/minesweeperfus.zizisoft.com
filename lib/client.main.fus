fus 2.2.1
import "babel-polyfill"
import "./shared.manifest" all

BOARD_SIZE: 9
MINE_COUNT: 10

shared: import "site/shared"
import "./shared.main"
client: import "site/client"
ui: client.ui
lit: client.lit

parseElement: s -> DOMParser().parseFromString(s, "application/xml").documentElement

inputBlocked: true
boardInputBlocked: true
clickOrHoldBlocked: true
board: repeat(BOARD_SIZE, <> repeat(BOARD_SIZE, <>
    {hasMine: false, swept: false, number: 0, flagged: false}
))
cells: null
flipper: null
hotBars: null

refreshBoard: <>
    randomBooleans:
        spread(true, MINE_COUNT)
        .concat(spread(false, BOARD_SIZE * BOARD_SIZE - MINE_COUNT))
        ..random()
    loop(BOARD_SIZE, x -> loop(BOARD_SIZE, y ->
        board.(x).(y).hasMine: randomBooleans.(x * BOARD_SIZE + y)
        board.(x).(y).swept: false
        board.(x).(y).flagged: false
    ))
    getMineCount: (x, y) ->
        if 0 <= x < BOARD_SIZE and 0 <= y < BOARD_SIZE and board.(x).(y).hasMine
            1
        else
            0
    loop(BOARD_SIZE, x -> loop(BOARD_SIZE, y ->
        board.(x).(y).number:
            getMineCount(x - 1, y)
            + getMineCount(x + 1, y)
            + getMineCount(x, y - 1)
            + getMineCount(x, y + 1)
            + getMineCount(x - 1, y - 1)
            + getMineCount(x + 1, y - 1)
            + getMineCount(x - 1, y + 1)
            + getMineCount(x + 1, y + 1)
    ))

getCell: pos -> cells.(pos.x * BOARD_SIZE + pos.y)

updateCell: pos ->
    cell: getCell(pos)
    if board.(pos.x).(pos.y).hasMine
        cell.setBackgroundPaint("rgb(255,0,0)")
        cell.getFirstChild().setSource("M")
    else
        cell.setBackgroundPaint("rgb(64,96,128)")
        cell.getFirstChild().setSource(board.(pos.x).(pos.y).number)

updateCellsAfterSwept: (pos, newlySweptPositions) -> Promise((resolve, reject) ->
    (flipper.getAnimation() ifnull Promise.resolve()).then(<>
        getCell(pos).hide()
        flipper.flip(1, 400)
    ).then(<>
        flipper.animate{to: {scale: 1}, duration: 200}
    ).then(<>
        if newlySweptPositions.length = 1
            updateCell(pos)
            getCell(pos).show()
            flipper.hide()
            resolve()
        else
            doneCount: 0
            newlySweptLines: repeat(BOARD_SIZE, <> [])
            newlySweptPositions.forEach(m ->
                newlySweptLines.(m.y).push(m.x)
            )
            loop(BOARD_SIZE, y ->
                hotBars.(y).setZIndex(1)
            )
            loop(BOARD_SIZE, y ->
                Promise..delay(y * 40).then(<>
                    hotBars.(y).animate{to: {opacity: 1}, duration: 200}
                ).then(<>
                    newlySweptLines.(y).forEach(x ->
                        updateCell{x: x, y: y}
                        cell: getCell{x: x, y: y}
                        if x = pos.x and y = pos.y
                            cell.show()
                            flipper.hide()
                    )
                    hotBars.(y).animate{to: {opacity: 0}, duration: 200}
                ).then(<>
                    doneCount: self + 1
                    if doneCount = BOARD_SIZE
                        loop(BOARD_SIZE, m ->
                            hotBars.(m).setZIndex(-1)
                        )
                        resolve()
                )
            )
    )
)

restoreCells: <> Promise((resolve, reject) ->
    doneCount: 0
    loop(BOARD_SIZE, y ->
        hotBars.(y).setZIndex(1)
    )
    loop(BOARD_SIZE, y ->
        Promise..delay(y * 40).then(<>
            hotBars.(y).animate{to: {opacity: 1}, duration: 200}
        ).then(<>
            loop(BOARD_SIZE, x ->
                updateCellFlaggedQuick({x: x, y: y}, false)
                if board.(x).(y).swept
                    cell: getCell{x: x, y: y}
                    cell.setBackgroundPaint("rgb(64,64,64)")
                    cell.getFirstChild().setSource("")
            )
            hotBars.(y).animate{to: {opacity: 0}, duration: 200}
        ).then(<>
            doneCount: self + 1
            if doneCount = BOARD_SIZE
                loop(BOARD_SIZE, m ->
                    hotBars.(m).setZIndex(-1)
                )
                resolve()
        )
    )
)

updateCellFlagged: (pos, flagged) ->
    (flipper.getAnimation() ifnull Promise.resolve()).then(<>
        flipper.animate{to: {scale: 1}, duration: 200}
    ).then(<>
        updateCellFlaggedQuick(pos, flagged)
    )

updateCellFlaggedQuick: (pos, flagged) ->
    flipper.hide()
    getCell(pos).setBackgroundPaint(flagged ? "rgb(255,192,0)" | "rgb(64,64,64)")

client.autoCloseStartup: false

if client.browser.deviceType = "computer" and (
    navigator.vendor = "Google Inc." or navigator.vendor = "Apple Computer, Inc."
)
    ui.enableAntiFraction()
ui.setRem(0.018)

client.onLoad(<>
    Promise.all[
        web.binaryGet("/3rd-party/SourceCodePro-Regular.otf.woff")
        web.binaryGet("/3rd-party/kaushan-script.woff")
    ].then(resources ->
        sourceCodeProUri: "data:application/font-woff;base64," + resources.0.body..toBase64()
        kaushanScriptUri: "data:application/font-woff;base64," + resources.1.body..toBase64()
        woffStyleElement: parseElement("
            <style type="text/css" xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
                @font-face {
                    font-family: "SourceCodeProWoff";
                    font-style: normal;
                    font-weight: 400;
                    src: url(\(sourceCodeProUri)) format("woff");
                }
                @font-face {
                    font-family: "Kaushan Script";
                    font-style: normal;
                    font-weight: 400;
                    src: local("Kaushan Script"), local("KaushanScript-Regular"), url(\(kaushanScriptUri)) format("woff");
                }
            ]]></style>
        ")
        document.head.appendChild(woffStyleElement)

        ui.setRoot ui.Stack(
            {
                backgroundPaint: "rgb(0,0,0)"
                width: 1
                height: 1
                padding: ui.Padding("0.5rem")
                scale: 0.000001
                rotate: "540deg"
            }
            ui.Stack(
                {
                    grow: 1
                    shrink: 1
                    padding: ui.Padding("1rem", "1rem")
                    childSpacing: "2rem"
                }
                ui.Stack(
                    {childSpacing: "1rem"}
                    ui.Text(lit.title, {fontSize: 5, textAlignment: "center"})
                    ui.Text(lit.hint, {fontSize: 1.8, textAlignment: "center"})
                )
                ui.Button(lit.newGame, {
                    fontSize: 2.4
                    border: {width: "0.1em", paint: "rgb(255,255,255)"}
                    padding: ui.Padding("0.75em", "0.75em")
                    click: <>
                        if not inputBlocked
                            inputBlocked: true
                            boardInputBlocked: true
                            clickOrHoldBlocked: true
                            restoreCells().then(<>
                                refreshBoard()
                                inputBlocked: false
                                boardInputBlocked: false
                            )
                })
            ) as bar
            ui.Board(
                {aspectRatio: 1}
                (repeat(BOARD_SIZE, x -> repeat(BOARD_SIZE, y ->
                    ui.Board(
                        {
                            x: (x + 0.5) / BOARD_SIZE
                            y: (y + 0.5) / BOARD_SIZE
                            width: 1 / BOARD_SIZE * 0.9
                            height: 1 / BOARD_SIZE * 0.9
                            backgroundPaint: "rgb(64,64,64)"
                            holdThreshold: 500
                            pointerDown: <>
                                if not inputBlocked and not boardInputBlocked and not board.(x).(y).swept
                                    clickOrHoldBlocked: false
                                    if board.(x).(y).hasMine
                                        flipper.getBackFace().setBackgroundPaint("rgb(255,0,0)")
                                        flipper.getBackFace().getFirstChild().setSource("M")
                                    else
                                        flipper.getBackFace().setBackgroundPaint("rgb(64,96,128)")
                                        flipper.getBackFace().getFirstChild().setSource(board.(x).(y).number)
                                    flipper
                                    .reset()
                                    .setX((x + 0.5) / BOARD_SIZE)
                                    .setY((y + 0.5) / BOARD_SIZE)
                                    .show()
                                    .animate{to: {scale: 2}, duration: 200}
                            click: <>
                                if not inputBlocked and not boardInputBlocked and not clickOrHoldBlocked
                                and not board.(x).(y).swept
                                    newlySweptPositions: []
                                    inputBlocked: true
                                    boardInputBlocked: true
                                    clickOrHoldBlocked: true
                                    if board.(x).(y).hasMine
                                        loop(BOARD_SIZE, m -> loop(BOARD_SIZE, n ->
                                            if not board.(m).(n).swept
                                                board.(m).(n).swept: true
                                                newlySweptPositions.push{x: m, y: n}
                                        ))
                                        updateCellsAfterSwept({x: x, y: y}, newlySweptPositions)
                                        .then(<>
                                            inputBlocked: false
                                        )
                                    else
                                        sweep: pos ->
                                            trySweep: (px, py) ->
                                                if 0 <= px < BOARD_SIZE and 0 <= py < BOARD_SIZE
                                                    sweep{x: px, y: py}
                                            if not board.(pos.x).(pos.y).swept
                                                board.(pos.x).(pos.y).swept: true
                                                newlySweptPositions.push(pos)
                                                if board.(pos.x).(pos.y).number = 0
                                                    trySweep(pos.x - 1, pos.y)
                                                    trySweep(pos.x + 1, pos.y)
                                                    trySweep(pos.x, pos.y - 1)
                                                    trySweep(pos.x, pos.y + 1)
                                                    trySweep(pos.x - 1, pos.y - 1)
                                                    trySweep(pos.x + 1, pos.y - 1)
                                                    trySweep(pos.x - 1, pos.y + 1)
                                                    trySweep(pos.x + 1, pos.y + 1)
                                        sweep{x: x, y: y}
                                        updateCellsAfterSwept({x: x, y: y}, newlySweptPositions)
                                        .then(<>
                                            inputBlocked: false
                                            boardInputBlocked: false
                                        )
                                        remaining: board..flatten().filter(m -> not m.swept)
                                        if remaining.length = MINE_COUNT
                                            alert("success!")
                            hold: <>
                                if not inputBlocked and not boardInputBlocked and not clickOrHoldBlocked
                                and not board.(x).(y).swept
                                    inputBlocked: true
                                    boardInputBlocked: true
                                    clickOrHoldBlocked: true
                                    board.(x).(y).flagged: not self
                                    updateCellFlagged({x: x, y: y}, board.(x).(y).flagged)
                                    .then(<>
                                        inputBlocked: false
                                        boardInputBlocked: false
                                    )
                            pointerDownLeave: <>
                                if not inputBlocked and not boardInputBlocked and not board.(x).(y).swept
                                    inputBlocked: true
                                    boardInputBlocked: true
                                    clickOrHoldBlocked: true
                                    flipper.animate{to: {scale: 1}, duration: 200}.then(<>
                                        flipper.hide()
                                        inputBlocked: false
                                        boardInputBlocked: false
                                    )
                            pointerUp: <>
                                clickOrHoldBlocked: true
                        }
                        ui.Text({fontSize: 27 / BOARD_SIZE}, "")
                    )
                ))..flatten() as cells).concat(
                    repeat(BOARD_SIZE, y ->
                        ui.Element{
                            y: (y + 0.5) / BOARD_SIZE
                            width: 1
                            height: 1 / BOARD_SIZE * 0.9
                            zIndex: -1
                            opacity: 0
                            backgroundPaint: "rgb(255,224,160)"
                        }
                    ) as hotBars
                ).concat[
                    ui.Flipper(
                        {
                            visibility: "hidden"
                            zIndex: 1
                            width: 1 / BOARD_SIZE * 0.9
                            height: 1 / BOARD_SIZE * 0.9
                            perspective: 0.875
                            orientation: "horizontal"
                            frontFace: ui.Board(
                                {
                                    backgroundPaint: "rgb(96,96,96)"
                                }
                            )
                            backFace: ui.Board(
                                ui.Text({fontSize: 27 / BOARD_SIZE}, "")
                            )

                            # If don't hide then IE 11 may show a very slim border. That's because
                            # IE has a bug with CSS "backface-visibility", so "backface-visibility"
                            # is actually disabled by Site Engine on IE 11.
                            hidesBackFace: client.browser.isIe11

                            pointerArea: "none"
                        }
                    ) as flipper
                ]
            ) as uiBoard
        )

        ui.root
        .setFontFamily(
            "\"Helvetica Neue\", Helvetica, Arial, \"Lucida Grande\", \"Lucida Sans Unicode\", "
            + "\"Lantinghei SC\", \"Microsoft YaHei UI\", \"Microsoft YaHei\", SimHei, sans-serif"
        ).setPaint("rgb(255,255,255)").setStrokeWidth(0.06)

        resizeHandler: <>
            if ui.root.computeWidth() < ui.root.computeHeight()
                ui.root.setHorizontal(false)
                bar.setHorizontal(true)
                uiBoard.setSize(1, "auto")
            else
                ui.root.setHorizontal(true)
                bar.setHorizontal(false)
                uiBoard.setSize("auto", 1)
        ui.onResize(resizeHandler)
        resizeHandler()

        client.closeStartup()

        Promise..delay(500).then(<>
            ui.root.animate{to: {scale: 1, rotate: "0deg"}, duration: 2000, timingFunction: "ease-in"}
        ).then(<>
            refreshBoard()
            inputBlocked: false
            boardInputBlocked: false
        )
    )
)
