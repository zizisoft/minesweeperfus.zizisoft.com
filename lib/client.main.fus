fus 2.1.0
import "babel-polyfill"
import "./shared.manifest" all

shared: import "site/shared"
import "./shared.main"
client: import "site/client"
ui: client.ui
lit: client.lit

parseElement: s -> DOMParser().parseFromString(s, "application/xml").documentElement

client.autoCloseStartup: false

BOARD_SIZE: 9
MINE_COUNT: 10

if navigator.vendor = "Google Inc." or navigator.vendor = "Apple Computer, Inc."
    ui.enableAntiFraction()
ui.setRem(0.018)

client.onLoad(<>
    Promise.all[
        web.binaryGet("/3rd-party/SourceCodePro-Regular.otf.woff")
        web.binaryGet("/3rd-party/kaushan-script.woff")
    ].then(resources ->
        sourceCodeProUri: "data:application/font-woff;base64," + resources.0.body..toBase64()
        kaushanScriptUri: "data:application/font-woff;base64," + resources.1.body..toBase64()
        woffStyleElement: parseElement("
            <style type="text/css" xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
                @font-face {
                    font-family: "SourceCodeProWoff";
                    font-style: normal;
                    font-weight: 400;
                    src: url(\(sourceCodeProUri)) format("woff");
                }
                @font-face {
                    font-family: "Kaushan Script";
                    font-style: normal;
                    font-weight: 400;
                    src: local("Kaushan Script"), local("KaushanScript-Regular"), url(\(kaushanScriptUri)) format("woff");
                }
            ]]></style>
        ")
        document.head.appendChild(woffStyleElement)

        playable: false

        getCell: pos -> cells.(pos.x * BOARD_SIZE + pos.y)

        updateCellsAfterSwept: (pos, newlySweptPositions) -> Promise((resolve, reject) ->
            flipper
            .setX((pos.x + 0.5) / BOARD_SIZE)
            .setY((pos.y + 0.5) / BOARD_SIZE)
            .show()
            .flip(1, 600)
            .then(<>
                if newlySweptPositions..isEmpty()
                    resolve()
                else
                    doneCount: 0
                    newlySweptLines: repeat(BOARD_SIZE, <> [])
                    newlySweptPositions.forEach(m ->
                        newlySweptLines.(m.y).push(m.x)
                    )
                    loop(BOARD_SIZE, y ->
                        scoreBars.(y).setZIndex(1)
                    )
                    loop(BOARD_SIZE, y ->
                        Promise..delay(y * 100).then(<>
                            scoreBars.(y).animate{to: {opacity: 1}, duration: 300}
                        ).then(<>
                            newlySweptLines.(y).forEach(x ->
                                cell: getCell{x: x, y: y}
                                if board.(x).(y).hasMine
                                    cell.setBackgroundPaint("rgb(255,0,0)")
                                    cell.getFirstChild().setSource("M")
                                else
                                    cell.setBackgroundPaint("rgb(64,96,128)")
                                    cell.getFirstChild().setSource(board.(x).(y).number)
                                if x = pos.x and y = pos.y
                                    flipper.hide()
                            )
                            scoreBars.(y).animate{to: {opacity: 0}, duration: 300}
                        ).then(<>
                            doneCount: self + 1
                            if doneCount = BOARD_SIZE
                                loop(BOARD_SIZE, m ->
                                    scoreBars.(m).setZIndex(-1)
                                )
                                resolve()
                        )
                    )
            )
        )

        restoreCells: <> Promise((resolve, reject) ->
            doneCount: 0
            loop(BOARD_SIZE, y ->
                scoreBars.(y).setZIndex(1)
            )
            loop(BOARD_SIZE, y ->
                Promise..delay(y * 100).then(<>
                    scoreBars.(y).animate{to: {opacity: 1}, duration: 300}
                ).then(<>
                    loop(BOARD_SIZE, x ->
                        updateCellFlagged({x: x, y: y}, false)
                        if board.(x).(y).swept
                            cell: getCell{x: x, y: y}
                            cell.setBackgroundPaint("rgb(64,64,64)")
                            cell.getFirstChild().setSource("")
                    )
                    scoreBars.(y).animate{to: {opacity: 0}, duration: 300}
                ).then(<>
                    doneCount: self + 1
                    if doneCount = BOARD_SIZE
                        loop(BOARD_SIZE, m ->
                            scoreBars.(m).setZIndex(-1)
                        )
                        resolve()
                )
            )
        )

        updateCellFlagged: (pos, flagged) ->
            getCell(pos).setBackgroundPaint(flagged ? "rgb(255,192,0)" | "rgb(64,64,64)")

        ui.setRoot ui.Stack(
            {backgroundPaint: "rgb(0,0,0)", width: 1, height: 1}
            ui.Stack(
                {
                    grow: 1
                    shrink: 1
                    padding: ui.Padding("1rem", "1rem")
                    childSpacing: "2rem"
                }
                ui.Stack(
                    {childSpacing: "1rem"}
                    ui.Text(lit.title, {fontSize: 5, textAlignment: "center"})
                    ui.Text(lit.hint, {fontSize: 1.8, textAlignment: "center"})
                )
                ui.Button(lit.newGame, {
                    fontSize: 2.4
                    border: {width: "0.1em", paint: "rgb(255,255,255)"}
                    padding: ui.Padding("0.75em", "0.75em")
                    click: <>
                        restoreCells().then(<>
                            randomBooleans:
                                spread(true, MINE_COUNT)
                                .concat(spread(false, BOARD_SIZE * BOARD_SIZE - MINE_COUNT))
                                ..random()
                            loop(BOARD_SIZE, x -> loop(BOARD_SIZE, y ->
                                board.(x).(y).hasMine: randomBooleans.(x * BOARD_SIZE + y)
                                board.(x).(y).swept: false
                                board.(x).(y).flagged: false
                            ))
                            getMineCount: (x, y) ->
                                0 <= x < BOARD_SIZE and 0 <= y < BOARD_SIZE and board.(x).(y).hasMine ? 1 | 0
                            loop(BOARD_SIZE, x -> loop(BOARD_SIZE, y ->
                                board.(x).(y).number:
                                    getMineCount(x - 1, y)
                                    + getMineCount(x + 1, y)
                                    + getMineCount(x, y - 1)
                                    + getMineCount(x, y + 1)
                                    + getMineCount(x - 1, y - 1)
                                    + getMineCount(x + 1, y - 1)
                                    + getMineCount(x - 1, y + 1)
                                    + getMineCount(x + 1, y + 1)
                            ))
                            playable: true
                        )
                }) as newGameButton
            ) as bar
            ui.Board(
                {aspectRatio: 1}
                (repeat(BOARD_SIZE, x -> repeat(BOARD_SIZE, y ->
                    ui.Board(
                        {
                            x: (x + 0.5) / BOARD_SIZE
                            y: (y + 0.5) / BOARD_SIZE
                            width: 1 / BOARD_SIZE * 0.9
                            height: 1 / BOARD_SIZE * 0.9
                            holdThreshold: 500
                            click: <>
                                if playable
                                    if not board.(x).(y).swept
                                        newlySweptPositions: []
                                        if board.(x).(y).hasMine
                                            playable: false
                                            loop(BOARD_SIZE, m -> loop(BOARD_SIZE, n ->
                                                if not board.(m).(n).swept
                                                    board.(m).(n).swept: true
                                                    newlySweptPositions.push{x: m, y: n}
                                            ))
                                            updateCellsAfterSwept({x: x, y: y}, newlySweptPositions)
                                        else
                                            sweep: pos ->
                                                trySweep: (px, py) ->
                                                    if 0 <= px < BOARD_SIZE and 0 <= py < BOARD_SIZE
                                                        sweep{x: px, y: py}
                                                if not board.(pos.x).(pos.y).swept
                                                    board.(pos.x).(pos.y).swept: true
                                                    newlySweptPositions.push(pos)
                                                    if board.(pos.x).(pos.y).number = 0
                                                        trySweep(pos.x - 1, pos.y)
                                                        trySweep(pos.x + 1, pos.y)
                                                        trySweep(pos.x, pos.y - 1)
                                                        trySweep(pos.x, pos.y + 1)
                                                        trySweep(pos.x - 1, pos.y - 1)
                                                        trySweep(pos.x + 1, pos.y - 1)
                                                        trySweep(pos.x - 1, pos.y + 1)
                                                        trySweep(pos.x + 1, pos.y + 1)
                                            sweep{x: x, y: y}
                                            updateCellsAfterSwept({x: x, y: y}, newlySweptPositions)
                                            remaining: board..flatten().filter(m -> not m.swept)
                                            if remaining.length = MINE_COUNT
                                                playable: false
                                                alert("success!")
                            hold: <>
                                if playable
                                    board.(x).(y).flagged: not self
                                    updateCellFlagged({x: x, y: y}, board.(x).(y).flagged)
                        }
                        ui.Text("")
                    )
                ))..flatten() as cells).concat(
                    repeat(BOARD_SIZE, y ->
                        ui.Element{
                            y: (y + 0.5) / BOARD_SIZE
                            width: 1
                            height: 1 / BOARD_SIZE * 0.9
                            zIndex: -1
                            opacity: 0
                            backgroundPaint: "rgb(255,255,255)"
                        }
                    ) as scoreBars
                ).concat[
                    ui.Flipper(
                        {
                            visibility: "hidden"
                            zIndex: 1
                            width: 1 / BOARD_SIZE * 0.9
                            height: 1 / BOARD_SIZE * 0.9
                            perspective: 1
                            orientation: "horizontal"
                            frontFace: ui.Board(
                                {
                                    border: {width: "0.3em", paint: "rgb(80,80,80)"}
                                }
                            )
                            backFace: ui.Board(
                                ui.Text({fontSize: 27 / BOARD_SIZE}, "")
                            )

                            # If don't hide then IE 11 may show a very slim border. That's because
                            # IE has a bug with CSS "backface-visibility", so "backface-visibility"
                            # is actually disabled by Site Engine on IE 11.
                            hidesBackFace: client.browser.isIe11

                        }
                    ) as flipper
                ]
            ) as uiBoard
        )

        ui.root
        .setFontFamily(
            "\"Helvetica Neue\", Helvetica, Arial, \"Lucida Grande\", \"Lucida Sans Unicode\", "
            + "\"Lantinghei SC\", \"Microsoft YaHei UI\", \"Microsoft YaHei\", SimHei, sans-serif"
        ).setPaint("rgb(255,255,255)").setStrokeWidth(0.06)

        board: repeat(BOARD_SIZE, <> repeat(BOARD_SIZE, <>
            {hasMine: false, swept: false, number: 0, flagged: false}
        ))
        newGameButton.onClick.fire()

        resizeHandler: <>
            if ui.root.computeWidth() < ui.root.computeHeight()
                ui.root.setHorizontal(false)
                bar.setHorizontal(true)
                uiBoard.setSize(1, "auto")
            else
                ui.root.setHorizontal(true)
                bar.setHorizontal(false)
                uiBoard.setSize("auto", 1)
        ui.onResize(resizeHandler)
        resizeHandler()

        client.closeStartup()
    )
)
