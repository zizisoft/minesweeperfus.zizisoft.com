fus 2.1.0
import "babel-polyfill"
import "./shared.manifest" all

shared: import "site/shared"
import "./shared.main"
client: import "site/client"
ui: client.ui
lit: client.lit

parseElement: s -> DOMParser().parseFromString(s, "application/xml").documentElement

if navigator.vendor = "Google Inc." or navigator.vendor = "Apple Computer, Inc."
    ui.enableAntiFraction()
ui.setRem(0.018)
ui.root
.setFontFamily(
    "\"Helvetica Neue\", Helvetica, Arial, \"Lucida Grande\", \"Lucida Sans Unicode\", "
    + "\"Lantinghei SC\", \"Microsoft YaHei UI\", \"Microsoft YaHei\", SimHei, sans-serif"
).setPaint("rgb(255,255,255)").setStrokeWidth(0.06)

client.onLoad(<>
    Promise.all[
        web.binaryGet("/3rd-party/SourceCodePro-Regular.otf.woff")
        web.binaryGet("/3rd-party/kaushan-script.woff")
    ].then(resources ->
        sourceCodeProUri: "data:application/font-woff;base64," + resources.0.body..toBase64()
        kaushanScriptUri: "data:application/font-woff;base64," + resources.1.body..toBase64()
        woffStyleElement: parseElement("
            <style type="text/css" xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
                @font-face {
                    font-family: "SourceCodeProWoff";
                    font-style: normal;
                    font-weight: 400;
                    src: url(\(sourceCodeProUri)) format("woff");
                }
                @font-face {
                    font-family: "Kaushan Script";
                    font-style: normal;
                    font-weight: 400;
                    src: local("Kaushan Script"), local("KaushanScript-Regular"), url(\(kaushanScriptUri)) format("woff");
                }
            ]]></style>
        ")
        document.head.appendChild(woffStyleElement)

        getCell: pos -> cells.(pos.x * 9 + pos.y)

        updateCellsAfterSwept: pos -> Promise((resolve, reject) ->
            checker: <>
                flippedCount: self + 1
                if flippedCount = totalCount
                    getCell(pos).setZIndex(0)
                    resolve()
            getCell(pos).setZIndex(1).flip(1, 600).then(checker)
            totalCount: 1
            flippedCount: 0
            promise: Promise..delay(20)
            loop(9, y -> loop(9, x ->
                cell: getCell{x: x, y: y}
                if not (x = pos.x and y = pos.y) and board.(x).(y).swept and not cell.isOdd()
                    totalCount: self + 1
                    promise: promise.then(<>
                        cell.flip(1, 600).then(checker)
                        Promise..delay(20)
                    )
            ))
        )

        restoreCells: <> Promise((resolve, reject) ->
            totalCount: 0
            flippedCount: 0
            promise: Promise..delay(20)
            loop(9, y -> loop(9, x ->
                if board.(x).(y).swept
                    cell: getCell{x: x, y: y}
                    totalCount: self + 1
                    promise: promise.then(<>
                        cell.flip(1, 600).then(<>
                            flippedCount: self + 1
                            if flippedCount = totalCount
                                resolve()
                        )
                        Promise..delay(20)
                    )
            ))
            if totalCount = 0 then resolve()
        )

        homeScene: ui.Stack(
            {backgroundPaint: "rgb(0,0,0)", scale: 0.001}
            ui.Stack(
                {
                    grow: 1
                    shrink: 1
                    padding: ui.Padding("1rem", "1rem")
                    childSpacing: "2rem"
                }
                ui.Stack(
                    {childSpacing: "1rem"}
                    ui.Text(lit.title, {fontSize: 5, textAlignment: "center"})
                    ui.Text(lit.hint, {fontSize: 1.8, textAlignment: "center"})
                )
                ui.Button(lit.newGame, {
                    fontSize: 2.4
                    border: {width: "0.1em", paint: "rgb(255,255,255)"}
                    padding: ui.Padding("0.75em", "0.75em")
                    click: <>
                        restoreCells().then(<>
                            randomBooleans: spread(true, 10).concat(spread(false, 71))..random()
                            loop(9, x -> loop(9, y ->
                                board.(x).(y).hasMine: randomBooleans.(x * 9 + y)
                                board.(x).(y).swept: false
                                board.(x).(y).flagged: false
                            ))
                            getMineCount: (x, y) ->
                                0 <= x < 9 and 0 <= y < 9 and board.(x).(y).hasMine ? 1 | 0
                            loop(9, x -> loop(9, y ->
                                board.(x).(y).number:
                                    getMineCount(x - 1, y)
                                    + getMineCount(x + 1, y)
                                    + getMineCount(x, y - 1)
                                    + getMineCount(x, y + 1)
                                    + getMineCount(x - 1, y - 1)
                                    + getMineCount(x + 1, y - 1)
                                    + getMineCount(x - 1, y + 1)
                                    + getMineCount(x + 1, y + 1)
                            ))
                            loop(9, x -> loop(9, y ->
                                cells.(x * 9 + y).getBackFace().setBackgroundPaint(
                                    if board.(x).(y).hasMine
                                        "rgb(255,0,0)"
                                    else
                                        "rgb(64,96,128)"
                                ).setBorder(
                                    if board.(x).(y).hasMine
                                        {width: "0.3em", paint: "rgb(255,0,0)"}
                                    else
                                        {width: "0.3em", paint: "rgb(80,112,144)"}
                                )
                                cells.(x * 9 + y).getBackFace().getFirstChild().setSource(
                                    if board.(x).(y).hasMine
                                        "M"
                                    else
                                        board.(x).(y).number
                                )
                            ))
                            overlay.hide()
                        )
                }) as newGameButton
            ) as bar
            ui.Board(
                {aspectRatio: 1}
                ui.Board(
                    repeat(9, x -> repeat(9, y ->
                        ui.Flipper(
                            {
                                x: (x + 0.5) / 9
                                y: (y + 0.5) / 9
                                width: 1 / 9 * 0.9
                                height: 1 / 9 * 0.9
                                perspective: "5rem"
                                orientation: "horizontal"
                                frontFace: ui.Board(
                                    {
                                        backgroundPaint: "rgb(64,64,64)"
                                        border: {width: "0.3em", paint: "rgb(80,80,80)"}
                                    }
                                )
                                backFace: ui.Board(
                                    ui.Text({fontSize: 3}, "")
                                )
                                holdThreshold: 500
                                click: <>
                                    if not board.(x).(y).swept
                                        if board.(x).(y).hasMine
                                            overlay.show()
                                            board.forEach(m -> m.forEach(n ->
                                                n.swept: true
                                            ))
                                            updateCellsAfterSwept{x: x, y: y}
                                        else
                                            sweep: pos ->
                                                trySweep: (px, py) ->
                                                    if 0 <= px < 9 and 0 <= py < 9
                                                        sweep{x: px, y: py}
                                                if not board.(pos.x).(pos.y).swept
                                                    board.(pos.x).(pos.y).swept: true
                                                    if board.(pos.x).(pos.y).number = 0
                                                        trySweep(pos.x - 1, pos.y)
                                                        trySweep(pos.x + 1, pos.y)
                                                        trySweep(pos.x, pos.y - 1)
                                                        trySweep(pos.x, pos.y + 1)
                                                        trySweep(pos.x - 1, pos.y - 1)
                                                        trySweep(pos.x + 1, pos.y - 1)
                                                        trySweep(pos.x - 1, pos.y + 1)
                                                        trySweep(pos.x + 1, pos.y + 1)
                                            sweep{x: x, y: y}
                                            updateCellsAfterSwept{x: x, y: y}
                                            remaining: board..flatten().filter(m -> not m.swept)
                                            if remaining.length = 10
                                                overlay.show()
                                                alert("success!")
                                hold: <>
                                    board.(x).(y).flagged: not self
                            }
                        )
                    ))..flatten() as cells
                )
                ui.Board{visibility: "hidden"} as overlay
            ) as uiBoard
        )
        sceneBox: ui.SceneBox(homeScene)
        ui.root.add(sceneBox)

        board: repeat(9, <> repeat(9, <> {hasMine: false, swept: false, number: 0, flagged: false}))
        newGameButton.onClick.fire()

        resizeHandler: <>
            if ui.root.computeWidth() < ui.root.computeHeight()
                homeScene.setHorizontal(false)
                bar.setHorizontal(true)
                uiBoard.setSize(1, "auto")
            else
                homeScene.setHorizontal(true)
                bar.setHorizontal(false)
                uiBoard.setSize("auto", 1)
        ui.onResize(resizeHandler)
        resizeHandler()

        sceneBox.showScene(
            homeScene
            (a, b, box, duration, timingFunction) ->
                b.setScale(0.001).show()
                (
                    if a'ok
                        a.animate{
                            to: {scale: 5, opacity: 0}
                            duration: duration / 2
                            timingFunction: "ease-in"
                        }
                    else
                        Promise.resolve()
                ).then(<>
                    b.animate{
                        to: {scale: 1}
                        duration: duration / 2
                        timingFunction: "cubic-bezier(0, 1, 0.8, 1.3)"
                    }
                ).then(<>
                    if a'ok
                        a.setScale(1).setOpacity(1)
                )
            1200
        )
    )
)
