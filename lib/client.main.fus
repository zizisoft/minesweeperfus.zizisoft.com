fus 2.1.0
import "babel-polyfill"
import "./shared.manifest" all

shared: import "site/shared"
import "./shared.main"
client: import "site/client"
ui: client.ui
lit: client.lit

parseElement: s -> DOMParser().parseFromString(s, "application/xml").documentElement

client.autoCloseStartup: false

BOARD_SIZE: 9
MINE_COUNT: 10

if navigator.vendor = "Google Inc." or navigator.vendor = "Apple Computer, Inc."
    ui.enableAntiFraction()
ui.setRem(0.018)

client.onLoad(<>
    Promise.all[
        web.binaryGet("/3rd-party/SourceCodePro-Regular.otf.woff")
        web.binaryGet("/3rd-party/kaushan-script.woff")
    ].then(resources ->
        sourceCodeProUri: "data:application/font-woff;base64," + resources.0.body..toBase64()
        kaushanScriptUri: "data:application/font-woff;base64," + resources.1.body..toBase64()
        woffStyleElement: parseElement("
            <style type="text/css" xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
                @font-face {
                    font-family: "SourceCodeProWoff";
                    font-style: normal;
                    font-weight: 400;
                    src: url(\(sourceCodeProUri)) format("woff");
                }
                @font-face {
                    font-family: "Kaushan Script";
                    font-style: normal;
                    font-weight: 400;
                    src: local("Kaushan Script"), local("KaushanScript-Regular"), url(\(kaushanScriptUri)) format("woff");
                }
            ]]></style>
        ")
        document.head.appendChild(woffStyleElement)

        playable: false

        getCell: pos -> cells.(pos.x * BOARD_SIZE + pos.y)

        updateCellsAfterSwept: pos -> Promise((resolve, reject) ->
            checker: <>
                flippedCount: self + 1
                if flippedCount = totalCount
                    getCell(pos).setZIndex(0)
                    resolve()
            getCell(pos).setZIndex(1).flip(1, 600).then(checker)
            totalCount: 1
            flippedCount: 0
            loop(BOARD_SIZE, y -> loop(BOARD_SIZE, x ->
                cell: getCell{x: x, y: y}
                if not (x = pos.x and y = pos.y) and board.(x).(y).swept and not cell.isOdd()
                    totalCount: self + 1
                    Promise..delay(20 * totalCount).then(<>
                        cell.flip(1, 600).then(checker)
                    )
            ))
        )

        restoreCells: <> Promise((resolve, reject) ->
            totalCount: 0
            flippedCount: 0
            loop(BOARD_SIZE, y -> loop(BOARD_SIZE, x ->
                updateCellFlagged({x: x, y: y}, false)
                if board.(x).(y).swept
                    cell: getCell{x: x, y: y}
                    totalCount: self + 1
                    Promise..delay(20 * totalCount).then(<>
                        cell.flip(1, 600).then(<>
                            flippedCount: self + 1
                            if flippedCount = totalCount
                                resolve()
                        )
                    )
            ))
            if totalCount = 0 then resolve()
        )

        updateCellFlagged: (pos, flagged) ->
            getCell(pos).getFrontFace().setBackgroundPaint(flagged ? "rgb(255,192,0)" | "rgb(64,64,64)")

        ui.setRoot ui.Stack(
            {backgroundPaint: "rgb(0,0,0)", width: 1, height: 1}
            ui.Stack(
                {
                    grow: 1
                    shrink: 1
                    padding: ui.Padding("1rem", "1rem")
                    childSpacing: "2rem"
                }
                ui.Stack(
                    {childSpacing: "1rem"}
                    ui.Text(lit.title, {fontSize: 5, textAlignment: "center"})
                    ui.Text(lit.hint, {fontSize: 1.8, textAlignment: "center"})
                )
                ui.Button(lit.newGame, {
                    fontSize: 2.4
                    border: {width: "0.1em", paint: "rgb(255,255,255)"}
                    padding: ui.Padding("0.75em", "0.75em")
                    click: <>
                        restoreCells().then(<>
                            randomBooleans:
                                spread(true, MINE_COUNT)
                                .concat(spread(false, BOARD_SIZE * BOARD_SIZE - MINE_COUNT))
                                ..random()
                            loop(BOARD_SIZE, x -> loop(BOARD_SIZE, y ->
                                board.(x).(y).hasMine: randomBooleans.(x * BOARD_SIZE + y)
                                board.(x).(y).swept: false
                                board.(x).(y).flagged: false
                            ))
                            getMineCount: (x, y) ->
                                0 <= x < BOARD_SIZE and 0 <= y < BOARD_SIZE and board.(x).(y).hasMine ? 1 | 0
                            loop(BOARD_SIZE, x -> loop(BOARD_SIZE, y ->
                                board.(x).(y).number:
                                    getMineCount(x - 1, y)
                                    + getMineCount(x + 1, y)
                                    + getMineCount(x, y - 1)
                                    + getMineCount(x, y + 1)
                                    + getMineCount(x - 1, y - 1)
                                    + getMineCount(x + 1, y - 1)
                                    + getMineCount(x - 1, y + 1)
                                    + getMineCount(x + 1, y + 1)
                            ))
                            loop(BOARD_SIZE, x -> loop(BOARD_SIZE, y ->
                                cells.(x * BOARD_SIZE + y).getBackFace().setBackgroundPaint(
                                    if board.(x).(y).hasMine
                                        "rgb(255,0,0)"
                                    else
                                        "rgb(64,96,128)"
                                ).setBorder(
                                    if board.(x).(y).hasMine
                                        {width: "0.3em", paint: "rgb(255,0,0)"}
                                    else
                                        {width: "0.3em", paint: "rgb(80,112,144)"}
                                )
                                cells.(x * BOARD_SIZE + y).getBackFace().getFirstChild().setSource(
                                    if board.(x).(y).hasMine
                                        "M"
                                    else
                                        board.(x).(y).number
                                )
                            ))
                            playable: true
                        )
                }) as newGameButton
            ) as bar
            ui.Board(
                {aspectRatio: 1}
                repeat(BOARD_SIZE, x -> repeat(BOARD_SIZE, y ->
                    ui.Flipper(
                        {
                            x: (x + 0.5) / BOARD_SIZE
                            y: (y + 0.5) / BOARD_SIZE
                            width: 1 / BOARD_SIZE * 0.9
                            height: 1 / BOARD_SIZE * 0.9
                            perspective: 1
                            orientation: "horizontal"
                            frontFace: ui.Board(
                                {
                                    border: {width: "0.3em", paint: "rgb(80,80,80)"}
                                }
                            )
                            backFace: ui.Board(
                                ui.Text({fontSize: 27 / BOARD_SIZE}, "")
                            )

                            # If don't hide then IE 11 may show a very slim border. That's because
                            # IE has a bug with CSS "backface-visibility", so "backface-visibility"
                            # is actually disabled by Site Engine on IE 11.
                            hidesBackFace: client.browser.isIe11

                            holdThreshold: 500
                            click: <>
                                if playable
                                    if not board.(x).(y).swept
                                        if board.(x).(y).hasMine
                                            playable: false
                                            board.forEach(m -> m.forEach(n ->
                                                n.swept: true
                                            ))
                                            updateCellsAfterSwept{x: x, y: y}
                                        else
                                            sweep: pos ->
                                                trySweep: (px, py) ->
                                                    if 0 <= px < BOARD_SIZE and 0 <= py < BOARD_SIZE
                                                        sweep{x: px, y: py}
                                                if not board.(pos.x).(pos.y).swept
                                                    board.(pos.x).(pos.y).swept: true
                                                    if board.(pos.x).(pos.y).number = 0
                                                        trySweep(pos.x - 1, pos.y)
                                                        trySweep(pos.x + 1, pos.y)
                                                        trySweep(pos.x, pos.y - 1)
                                                        trySweep(pos.x, pos.y + 1)
                                                        trySweep(pos.x - 1, pos.y - 1)
                                                        trySweep(pos.x + 1, pos.y - 1)
                                                        trySweep(pos.x - 1, pos.y + 1)
                                                        trySweep(pos.x + 1, pos.y + 1)
                                            sweep{x: x, y: y}
                                            updateCellsAfterSwept{x: x, y: y}
                                            remaining: board..flatten().filter(m -> not m.swept)
                                            if remaining.length = MINE_COUNT
                                                playable: false
                                                alert("success!")
                            hold: <>
                                if playable
                                    board.(x).(y).flagged: not self
                                    updateCellFlagged({x: x, y: y}, board.(x).(y).flagged)
                        }
                    )
                ))..flatten() as cells
            ) as uiBoard
        )

        ui.root
        .setFontFamily(
            "\"Helvetica Neue\", Helvetica, Arial, \"Lucida Grande\", \"Lucida Sans Unicode\", "
            + "\"Lantinghei SC\", \"Microsoft YaHei UI\", \"Microsoft YaHei\", SimHei, sans-serif"
        ).setPaint("rgb(255,255,255)").setStrokeWidth(0.06)

        board: repeat(BOARD_SIZE, <> repeat(BOARD_SIZE, <>
            {hasMine: false, swept: false, number: 0, flagged: false}
        ))
        newGameButton.onClick.fire()

        resizeHandler: <>
            if ui.root.computeWidth() < ui.root.computeHeight()
                ui.root.setHorizontal(false)
                bar.setHorizontal(true)
                uiBoard.setSize(1, "auto")
            else
                ui.root.setHorizontal(true)
                bar.setHorizontal(false)
                uiBoard.setSize("auto", 1)
        ui.onResize(resizeHandler)
        resizeHandler()

        client.closeStartup()
    )
)
